package seta;

import org.eclipse.paho.client.mqttv3.*;
import ride.Ride;
import unimi.dps.ride.Ride.RideMsg;
import utils.Position;
import utils.Utils;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.sql.Timestamp;
import java.util.*;

/* Main process that simulates the taxi service requests generated by the
citizens of the smart city. */
public class Seta {
    private MqttClient client;
    private MqttConnectOptions connOpts;
    private int qos;
    private List<Ride> pendingRides;            // List of pending rides
    private Map<String, Integer> nTaxiMap;      // Maps that keeps the number of taxis available for each district

    public Seta() {
        this.pendingRides = new ArrayList<>();
        this.nTaxiMap = new HashMap<>();
    }

    public static void main (String argv[]){
        Seta seta = new Seta();
        seta.start();
    }

    public void start(){
        try {
            initializeComponents();
            System.out.println("> Seta correctly initialized.");
//            BufferedReader inFromUser = new BufferedReader(new InputStreamReader(System.in));

/*            while(true) {
                System.out.print("> press ENTER to create a ride\n");
                try {
                    if (inFromUser.readLine().equals(""));
                    publishNewRide();
                }catch (Exception e){
                    System.out.println("An error occurred. Please insert a value\n");
                }
            }*/
            while (true){
            // Two rides are published every 5 seconds
                publishRide();
                publishRide();
                Thread.sleep(10000);
            }
        }catch (MqttException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public void initializeComponents() throws MqttException {

        client = new MqttClient(Utils.MQTTBrokerAddress, MqttClient.generateClientId());
        connOpts = new MqttConnectOptions();
        connOpts.setCleanSession(true);       
        qos = 2;
        //The client is now connected to the broker
        client.connect(connOpts);

        client.setCallback(new MqttCallback() {
            @Override
            public void connectionLost(Throwable cause) {

            }

            @Override
            public void messageArrived(String topic, MqttMessage message) throws Exception {
                String time = new Timestamp(System.currentTimeMillis()).toString();

                switch (topic){
                    case "seta/smartcity/rides/completed":
                        RideMsg rideMsg =  RideMsg.parseFrom(message.getPayload());
                        System.out.println("************************RIDE COMPLETED***********************************");
                        System.out.println("Message Arrived at Time: " + time + "  Topic: " + topic + "  Message: "
                                + rideMsg.toString());
                        System.out.println("***********************************************************************");
                        removePendingRideFromList(rideMsg);
                        break;
                    case "seta/smartcity/taxi/available/":

                }
            }

            @Override
            public void deliveryComplete(IMqttDeliveryToken token) {

            }
        });

        // Subscribes to save pending rides
        client.subscribe(Utils.rideCompletedTopic, qos);
    }

    /* Remove pending ride from list */
    private synchronized void removePendingRideFromList(RideMsg rideMsg){
        Ride ride = new Ride(rideMsg);
        if (containsRide(ride.getId())) {
            pendingRides.remove(ride);
            System.out.println("> Pending ride " + ride.getId() + " removed from list ");
        }
    }


    /* The ride is added to the pending list */
    private synchronized void addPendingRideToList(Ride ride){
        if (!containsRide(ride.getId())) {
            pendingRides.add(ride);
            System.out.println("> Pending ride " + ride.getId() + " added to list ");
        }
    }

    private boolean containsRide(String id){
        for (Ride r : pendingRides){
            if (r.getId().equals(id))
                return true;
        }
        return false;
    }

    private synchronized Ride getFirstRide(){
        Ride r = null;
        if (pendingRides.size() > 0){
            r = pendingRides.get(0);
            pendingRides.remove(0);
        }
        return r;
    }

    /* Create a new ride */
    private Ride createNewRide(String id){
        Position start = Utils.getRandomPosition();
        Position finish;
        do {
            finish = Utils.getRandomPosition();
        }while (finish.equals(start));

        Ride r = new Ride(id, start, finish);
        // Sets the message with the ride infos to be sent to the taxi network
        return r;
    }



    public void publishRide() throws MqttException {
        RideMsg rideMsg;
        Ride ride = getFirstRide();
        /* If there is a pending ride, publishes that again, otherwise
        * create a new ride from scratch */
        //if (ride != null) {
        //    rideMsg = ride.createRideMsg();
        //    System.out.println("> Republishing pending ride " + ride);
        //} else {
            // Create the rides with a positive random id
            Ride r = createNewRide(String.valueOf(Math.abs(new Random().nextInt())));
            addPendingRideToList(r);
            rideMsg = r.createRideMsg();
        //}
        MqttMessage msg = new MqttMessage(rideMsg.toByteArray());
        msg.setQos(qos);
        client.publish(Utils.getDistrictTopicFromPosition(new Position(rideMsg.getStart())), msg);
        System.out.println("> RideMsg published:" + rideMsg);

        //TODO client disconnect
    }

}
