package seta;

import com.google.protobuf.TextFormat;
import org.eclipse.paho.client.mqttv3.*;
import ride.Ride;
import unimi.dps.ride.Ride.RideMsg;
import utils.Position;
import utils.Utils;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/* Main process that simulates the taxi service requests generated by the
citizens of the smart city. */
public class Seta {
    private SetaUtils setaUtils;
    private int rideCounter = 0;

    public Seta() {
        setaUtils = SetaUtils.getInstance();
    }

    public static void main (String argv[]){
        Seta seta = new Seta();
        seta.start();
    }

    public void start(){
        try {
            initializeComponents();
            System.out.println("> Seta correctly initialized.");
            while (true){
                // Two rides or more are published every 5 seconds
                publishRides();
                printSetaStatus();
                //setaUtils.resetIsSentStatus();
                // Reset is sent status
                Thread.sleep(10000);
            }
        }catch (MqttException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public void initializeComponents() throws MqttException {

        setaUtils.setClient( new MqttClient(Utils.MQTTBrokerAddress, MqttClient.generateClientId()));
        setaUtils.setConnOpts(new MqttConnectOptions());
        setaUtils.getConnOpts().setCleanSession(true);
        setaUtils.setQos(2);
        //The client is now connected to the broker
        setaUtils.getClient().connect(setaUtils.getConnOpts());

        setaUtils.getClient().setCallback(new MqttCallback() {
            @Override
            public void connectionLost(Throwable cause) {

            }

            @Override
            public void messageArrived(String topic, MqttMessage message) throws Exception {
                if (topic.equals(Utils.TAKEN_RIDE)){
                    RideMsg rideMsg =  RideMsg.parseFrom(message.getPayload());
                    setaUtils.removePendingRideFromMap(rideMsg);
                }else {
                    String topic2 = topic.substring(0,topic.length() - 1);
                    switch (topic2){
                        case Utils.TAXI_AVAILABLE:     //Update counter for the taxi in each district
                            int k1 = Integer.parseInt(String.valueOf(topic.charAt(topic.length() -1 )));
                            System.out.println("> TAXI AVAILABLE AT DISTRICT "+k1);
                            setaUtils.updateNTaxiMap(k1, setaUtils.getNTaxiForDistrict(k1) +1 );
                            break;
                        case Utils.TAXI_UNAVAILABLE:
                            int k2 = Integer.parseInt(String.valueOf(topic.charAt(topic.length() -1 )));
                            System.out.println("> TAXI UNAVAILABLE FROM DISTRICT: " + k2);
                            setaUtils.updateNTaxiMap(k2, Math.min(setaUtils.getNTaxiForDistrict(k2) - 1, 0));
                            break;
                    }
                }
            }

            @Override
            public void deliveryComplete(IMqttDeliveryToken token) {

            }
        });

        // Subscribes to various topics
        setaUtils.getClient().subscribe(Utils.TAKEN_RIDE, setaUtils.getQos());
        setaUtils.getClient().subscribe(Utils.TAXI_AVAILABLE + "#", setaUtils.getQos());
        setaUtils.getClient().subscribe(Utils.TAXI_UNAVAILABLE + "#", setaUtils.getQos());
    }

    public void publishRides() throws MqttException, InterruptedException {
        unimi.dps.ride.Ride.RideMsg rideMsg;
        /* If there is a taxi available, publishes again a pending ride, otherwise
         * create a new ride from scratch */
        List<Ride> publishList = new ArrayList<>();

        //Publish n rides for n taxis presents, otherwise publish two new rides

        for(int i=1; i<=4; i++){
            List<Ride> rides = setaUtils.getPendingRidesFromDistrict(i);
            if (rides != null){
                int ntaxi = setaUtils.getNTaxiForDistrict(i);
                int nrides = rides.size();
                // There is at least a taxi available and a pending ride in that district
                if (ntaxi > 0 && nrides>0){
                    //Adds a ride for each taxi, or all pending rides for that district
                    publishList.addAll(setaUtils.getPendingRidesFromDistrict(i)
                                                .stream()
                                                .limit(Math.min(ntaxi,nrides))
                                                .collect(Collectors.toList()));
                }
            }
        }

        switch (publishList.size()){
            case 0:
                /* No taxi available or pending rides were found, create two new rides */
                Ride r1 = createNewRide(String.valueOf(++rideCounter));
                setaUtils.addPendingRideToMap(r1);
                publishList.add(r1);
            case 1:
                //Only one ride was added, publish another random one
                Ride r2 = createNewRide(String.valueOf(++rideCounter));
                setaUtils.addPendingRideToMap(r2);
                publishList.add(r2);
                break;
            default:
                break;
        }

        //Publish each ride in publishList
        for (Ride ride : publishList) {
            rideMsg = ride.createRideMsg();
            MqttMessage msg = new MqttMessage(rideMsg.toByteArray());
            msg.setQos(setaUtils.getQos());
            System.out.println("> D" + Utils.getDistrictFromPosition(new Position(rideMsg.getStart())) + " PUBLISHING RIDE:" + TextFormat.shortDebugString(rideMsg));
            setaUtils.getClient().publish(Utils.getDistrictTopicFromPosition(new Position(rideMsg.getStart())), msg);
        }
    }

    /* Create a new ride */
    private Ride createNewRide(String id){
        Position start = Utils.getRandomPosition();
        Position finish;
        do {
            finish = Utils.getRandomPosition();
        }while (finish.equals(start));

        // Sets the message with the ride infos to be sent to the taxi network
        return new Ride(id, start, finish);
    }

    private void printSetaStatus(){
        StringBuilder bdr = new StringBuilder("> Current SETA status: ").append("\n");
        for(int i = 1; i<= 4 ; i++){
            bdr.append(" D").append(i).append(": ").append(setaUtils.getNTaxiForDistrict(i)).append(" taxi; ");
            if (setaUtils.getPendingRidesFromDistrict(i) != null)
                bdr.append(setaUtils.getPendingRidesFromDistrict(i).size());
            else
                bdr.append("0");

            bdr.append(" RIDES").append("\n");
        }
        System.out.println(bdr);
    }
}
