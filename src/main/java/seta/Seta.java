package seta;

import com.google.protobuf.TextFormat;
import org.eclipse.paho.client.mqttv3.*;
import ride.Ride;
import unimi.dps.ride.Ride.RideMsg;
import utils.Position;
import utils.Utils;

import java.sql.Timestamp;
import java.util.*;

/* Main process that simulates the taxi service requests generated by the
citizens of the smart city. */
public class Seta {
    private MqttClient client;
    private MqttConnectOptions connOpts;
    private int qos;
    private Map<Integer,List<Ride>> pendingRides;               // Map of pending rides by district
    private Map<Integer, Integer> nTaxiMap;                     // Maps that keeps the number of taxis available for each district

    public Seta() {
        this.pendingRides = new HashMap<>();
        //Map initialized with all values to 0 for each district
        this.nTaxiMap = new HashMap<Integer,Integer>(){{
                                                        put(1,0);
                                                        put(2,0);
                                                        put(3,0);
                                                        put(4,0);
                                                    }};
    }

    public static void main (String argv[]){
        Seta seta = new Seta();
        seta.start();
    }

    public void start(){
        try {
            initializeComponents();
            System.out.println("> Seta correctly initialized.");
//            BufferedReader inFromUser = new BufferedReader(new InputStreamReader(System.in));

/*            while(true) {
                System.out.print("> press ENTER to create a ride\n");
                try {
                    if (inFromUser.readLine().equals(""));
                    publishNewRide();
                }catch (Exception e){
                    System.out.println("An error occurred. Please insert a value\n");
                }
            }*/
            while (true){
                // Two rides are published every 5 seconds
                publishRide();
                publishRide();
                printSetaStatus();
                Thread.sleep(10000);
            }
        }catch (MqttException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public void initializeComponents() throws MqttException {

        client = new MqttClient(Utils.MQTTBrokerAddress, MqttClient.generateClientId());
        connOpts = new MqttConnectOptions();
        connOpts.setCleanSession(true);       
        qos = 2;
        //The client is now connected to the broker
        client.connect(connOpts);

        client.setCallback(new MqttCallback() {
            @Override
            public void connectionLost(Throwable cause) {

            }

            @Override
            public void messageArrived(String topic, MqttMessage message) throws Exception {
                String time = new Timestamp(System.currentTimeMillis()).toString();
                if (topic.equals(Utils.COMPLETED_RIDE)){
                    RideMsg rideMsg =  RideMsg.parseFrom(message.getPayload());
                    System.out.println("> RIDE COMPLETED");
                    removePendingRideFromMap(rideMsg);
                }else {
                    String topic2 = topic.substring(0,topic.length() - 1);
                    switch (topic2){
                        case Utils.TAXI_AVAILABLE:     //Update counter for the taxi in each district
                            char k1 = topic.charAt(topic.length() -1 );
                            System.out.println("> TAXI AVAILABLE AT DISTRICT "+k1);
                            updateNTaxiMap(k1, getNTaxiForDistrict(k1) +1 );
                            break;
                        case Utils.CHANGED_DISTRICT:
                            int k2 = topic.charAt(topic.length() -1 );
                            System.out.println("> TAXI CHANGED DISTRICT: " + k2);
                            updateNTaxiMap(k2, getNTaxiForDistrict(k2) -1 );
                            break;
                    }
                }
            }

            @Override
            public void deliveryComplete(IMqttDeliveryToken token) {

            }
        });

        // Subscribes to various topics
        client.subscribe(Utils.COMPLETED_RIDE, qos);
        client.subscribe(Utils.TAXI_AVAILABLE + "#", qos);
        client.subscribe(Utils.CHANGED_DISTRICT + "#", qos);
    }

    /* Remove pending ride from list */
    private synchronized void removePendingRideFromMap(RideMsg rideMsg){
        Ride ride = new Ride(rideMsg);
        int distr = Utils.getDistrictFromPosition(ride.getStart());
        if (containsRide(distr, ride.getId())) {
            List<Ride> rideList = getPendingRidesFromDistrict(distr);
            pendingRides.put(distr, removeRideFromList(rideList,rideMsg.getId()));
            System.out.println("> Pending ride " + ride.getId() + " removed from list ");
        }
    }


    /* The ride is added to the pending list */
    private synchronized void addPendingRideToMap(Ride ride){
        int distr = Utils.getDistrictFromPosition(ride.getStart());

        if (!containsRide(distr, ride.getId())) {
            List<Ride> rideList = getPendingRidesFromDistrict(distr);

            if (rideList == null)
                rideList = new ArrayList<>();

            rideList.add(ride);
            pendingRides.put(distr, rideList);
            System.out.println("> Pending ride " + ride.getId() + " added to list ");
        }
    }

    /* Returns true if a ride from a certain district was still pending */
    private boolean containsRide(int district, String id){
        List<Ride> districtPendingRides = getPendingRidesFromDistrict(district);
        if (districtPendingRides != null) {
            for (Ride r : districtPendingRides) {
                if (r.getId().equals(id))
                    return true;
            }
        }
        return false;
    }

    private List<Ride> removeRideFromList(List<Ride> list, String id){
        int index = 0;
        for (Ride r : list){
            if (r.getId().equals(id))
                index = list.indexOf(r);
        }

        list.remove(index);
        return list;
    }

    public synchronized List<Ride> getPendingRidesFromDistrict(int district) {
        return pendingRides.get(district);
    }

    public void setPendingRides(Map<Integer, List<Ride>> pendingRides) {
        this.pendingRides = pendingRides;
    }

    /* Create a new ride */
    private Ride createNewRide(String id){
        Position start = Utils.getRandomPosition();
        Position finish;
        do {
            finish = Utils.getRandomPosition();
        }while (finish.equals(start));

        Ride r = new Ride(id, start, finish);
        // Sets the message with the ride infos to be sent to the taxi network
        return r;
    }

    public synchronized Ride getFirstPendingRideFromDistrict(int distr){
        return getPendingRidesFromDistrict(distr).get(0);
    }

    public void publishRide() throws MqttException {
        RideMsg rideMsg;
        /* If there is a taxi available, publishes again a pending ride, otherwise
        * create a new ride from scratch */
        Ride r = null;

        for(int i=1; i<=4; i++){
            // There is at least a taxi available and a pending ride in that district
            if (getNTaxiForDistrict(i) > 0 && getPendingRidesFromDistrict(i).size()>0){
                //Gets the first pending ride
                r = getFirstPendingRideFromDistrict(i);
            }
        }
        /* No taxi available or pending rides were found, create new ride*/
        if (r == null){
            // Create the rides with a positive random id
            r = createNewRide(String.valueOf(Math.abs(new Random().nextInt())));
            addPendingRideToMap(r);
        }

        rideMsg = r.createRideMsg();

        MqttMessage msg = new MqttMessage(rideMsg.toByteArray());
        msg.setQos(qos);
        client.publish(Utils.getDistrictTopicFromPosition(new Position(rideMsg.getStart())), msg);
        System.out.println("> RideMsg published:" + TextFormat.shortDebugString(rideMsg));

        //TODO client disconnect
    }

    private synchronized void updateNTaxiMap(int k, int v){
        nTaxiMap.put(k,v);
    }

    private synchronized Integer getNTaxiForDistrict(int k){
        return nTaxiMap.get(k);
    }

    private void printSetaStatus(){
        StringBuilder bdr = new StringBuilder("> Current SETA status: ").append("\n");
        for(int i = 1; i<= 4 ; i++){
            bdr.append(" DSTR").append(i).append(": ").append(nTaxiMap.get(i)).append(" taxi; ");
            if (pendingRides.get(i) != null)
                bdr.append(pendingRides.get(i).size());
            else
                bdr.append("0");

            bdr.append(" RIDES").append("\n");
        }
        System.out.println(bdr);
    }
}
